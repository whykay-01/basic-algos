% me=0 student solutions (ps file), me=1 - my solutions (sol file),
% me=2 - assignment (hw file)
\def\me{0} \def\num{5} %homework number

\def\due{11:55 pm on Thursday, April 4} %due date

\def\course{CSCI-UA 310-007, Basic Algorithms} %course name, changed only once

% **** INSERT YOUR NAME HERE ****
\def\name{Yan Konichshev}

% **** INSERT YOUR NETID HERE ****
\def\netid{yk2602}

% **** INSERT NETIDs OF YOUR COLLABORATORS HERE ****
\def\collabs{N/A, N/A}


\iffalse

INSTRUCTIONS: replace # by the homework number.  (if this is not
ps#.tex, use the right file name)

Clip out the ********* INSERT HERE ********* bits below and insert
appropriate LaTeX code.  There is a section below for student macros.
It is not recommended to change any other parts of the code.


\fi
%

\documentclass[11pt]{article}


% ==== Packages ====
\usepackage{amsfonts,amsmath}
\usepackage{latexsym}
\usepackage{etoolbox}
\usepackage{totcount}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage[bottom]{footmisc}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{graphicx}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\setlength{\footskip}{1in} \setlength{\textheight}{8.5in}

\newcommand{\handout}[5]{
	\renewcommand{\thepage}{#1, Page \arabic{page}}
	\noindent
	\begin{center}
		\framebox{ \vbox{ \hbox to 5.78in { {\bf \course} \hfill #2 }
				\vspace{4mm} \hbox to 5.78in { {\Large \hfill #5 \hfill} }
				\vspace{2mm} \hbox to 5.78in { {\it #3 \hfill #4} }
				\ifnum\me=0
				\vspace{2mm} \hbox to 5.78in { {\it Collaborators: \collabs
						\hfill} }
				\fi
		} }
	\end{center}
	\vspace*{4mm}
}

\newcounter{pppp}
\newcounter{pppc}
\newcommand{\prob}{\arabic{pppp}} %problem number
\newcommand{\increase}{\stepcounter{pppp}\stepcounter{pppc}} %problem number

% Arguments: Title, Number of Points
\newcommand{\newproblem}[2]{
	\increase
	\restartlist{subtasks}
	\ifnum\me=0
	\ifnum\prob>0 \newpage \fi
	\setcounter{page}{1}
	\handout{\name{} (\netid), Homework \num, Problem \arabic{pppp}}
	{\today}{Name: \name{} (\netid)}{Due: \due}
	{Solutions to Problem \prob\ of Homework \num\ (#2)}
	\else
	\section*{Problem \num-\prob~(#1) \hfill {#2}}
	\fi
}

\newlist{subtasks}{enumerate}{1}
\setlist[subtasks]{label={(\alph*)},resume}

\newcounter{numpppp}
\loop
\stepcounter{numpppp}
% workaround bug in totcount (means \newtotcounter{points\arabic{pointsct}})
\begingroup%
\edef\tempcounter@@name{points\arabic{numpppp}}%
\expandafter\newtotcounter\expandafter{\tempcounter@@name}%
\edef\tempcounter@@name{ecpoints\arabic{numpppp}}%
\expandafter\newtotcounter\expandafter{\tempcounter@@name}%
\endgroup
\ifnum \value{numpppp}<500 % max number of tasks supported
\repeat

% formating of output
\newcommand{\disppoints}[1]{%
	\texorpdfstring{(#1~\ifnumequal{#1}{1}{point}{points})}{}
}

% adds and displays
\newcommand{\points}[1]{%
	\texorpdfstring{\addtocounter{points\arabic{pppc}}{#1}\disppoints{#1}}{}%
}
\newcommand{\ecpoints}[1]{%
	\texorpdfstring{\addtocounter{ecpoints\arabic{pppc}}{#1}\ec \disppoints{#1}}{}%
}

% total points of current task         
\newcommand{\currentpoints}{% total points of current task   
	\texorpdfstring{\ifnumequal{\totvalue{ecpoints\arabic{pppc}}}{0}%
		{\total{points\arabic{pppc}} points}%
		{\total{points\arabic{pppc}}+\total{ecpoints\arabic{pppc}} points}}{}%
}

\newcommand{\mixedpoints}[2]{%
	\texorpdfstring{%
		\addtocounter{points\arabic{pppc}}{#1}%
		\addtocounter{ecpoints\arabic{pppc}}{#2}%
		(#1 (+#2) points)
	}{}%
}


\def\squarebox#1{\hbox to #1{\hfill\vbox to #1{\vfill}}}
\def\qed{\hspace*{\fill}
	\vbox{\hrule\hbox{\vrule\squarebox{.667em}\vrule}\hrule}}
\newenvironment{solution}{\begin{trivlist}\item[]{\bf Solution:}}
	{\qed \end{trivlist}}
\newenvironment{solsketch}{\begin{trivlist}\item[]{\bf Solution
			Sketch:}} {\qed \end{trivlist}}
\newenvironment{code}{\begin{tabbing}
		12345\=12345\=12345\=12345\=12345\=12345\=12345\=12345\= \kill }
	{\end{tabbing}}


\newcommand{\hint}[1]{({\bf Hint}: {#1})}
% Put more macros here, as needed.
\newcommand{\room}{\medskip\ni}
\newcommand{\brak}[1]{\langle #1 \rangle}
\newcommand{\bit}[1]{\{0,1\}^{#1}}
\newcommand{\zo}{\{0,1\}}
\newcommand{\C}{{\cal C}}

\newcommand{\nin}{\not\in}
\newcommand{\set}[1]{\{#1\}}
\renewcommand{\ni}{\noindent}
\renewcommand{\gets}{\leftarrow}
\renewcommand{\to}{\rightarrow}
\newcommand{\assign}{:=}

\newcommand{\AND}{\wedge}
\newcommand{\OR}{\vee}
\newcommand{\For}{\mbox{\bf for }}
\newcommand{\To}{\mbox{\bf to }}
\newcommand{\DownTo}{\mbox{\bf downto }}
\newcommand{\Do}{\mbox{\bf do }}
\newcommand{\If}{\mbox{\bf if }}
\newcommand{\Then}{\mbox{\bf then }}
\newcommand{\Else}{\mbox{\bf else }}
\newcommand{\Elif}{\mbox{\bf elif }}
\newcommand{\While}{\mbox{\bf while }}
\newcommand{\Repeat}{\mbox{\bf repeat }}
\newcommand{\Until}{\mbox{\bf until }}
\newcommand{\Return}{\mbox{\bf return }}
\newcommand{\Halt}{\mbox{\bf halt }}
\newcommand{\Swap}{\mbox{\bf swap }}
\newcommand{\Ex}[2]{\textrm{exchange } #1 \textrm{ with } #2}
\newcommand{\Nil}{\mbox{\bf nil}}
\newcommand{\In}{\mathsf{inOrder}}
\newcommand{\Post}{\mathsf{postOrder}}
\newcommand{\Pre}{\mathsf{preOrder}}
\newcommand{\Root}{\mathsf{root}}
\newcommand{\Parent}{\mathsf{parent}}
\newcommand{\Left}{\mathsf{left}}
\newcommand{\Right}{\mathsf{right}}
\newcommand{\Middle}{\mathsf{middle}}
\newcommand{\True}{\textbf{true}}
\newcommand{\False}{\textbf{false}}
\newcommand{\Print}{\mbox{\bf print }}
\newcommand{\ec}{({\bf Extra Credit})}
\newcommand{\note}{{\bf Note to Graders: }}
\newcommand{\Rotate}{\textsc{Rotate}}
\newcommand{\LRotate}{\textsc{LeftRotate}}
\newcommand{\RRotate}{\textsc{RightRotate}}

\newcommand{\notename}[2]{{\textcolor{red}{\footnotesize{\bf (#1:} {#2}{\bf ) }}}}
\newcommand{\sparsh}[1]{{\notename{Sparsh}{#1}}}

\newcommand{\noname}[2]{{\textcolor{purple}{\footnotesize{\bf (#1:} {#2}{\bf ) }}}}
\newcommand{\tanmay}[1]{{\noname{Tanmay}{#1}}}
\newcommand{\Gray}{\textsc{gray}}
\newcommand{\White}{\textsc{white}}
\newcommand{\Black}{\textsc{black}}

\begin{document}

\ifnum\me=0

% Collaborators (on a per task basis):
%
% Task 1: *********** INSERT COLLABORATORS HERE *********** 
% Task 2: *********** INSERT COLLABORATORS HERE *********** 
% etc.  
%

\fi

% \handout{\name{} (\netid), Homework \num, Problem \arabic{pppp}}
% 	{\today}{Name: \name{} }{Due: \due}
% 	{Homework 4}

\newproblem{Collaborators}{0 points}
    \noindent
Add the names and NetID(s) of your collaborators at the start of your solution file. If you haven't collaborated with anyone then say none. Do not leave it blank! You are allowed to consult external resources but you must write the solutions on your own keeping your resources closed. You must mention your resources here. 
\ifnum\me<2
\begin{solution}   N/A
\end{solution}
\fi

\newproblem{Bore}{\currentpoints}


\noindent



\begin{subtasks}
 \item \points{2}
        Draw a DAG for the following adjacency list. 
        \begin{align*}
0 & \rightarrow [1, 3, 4] \\
1 & \rightarrow [2, 5] \\
2 & \rightarrow [6] \\
3 & \rightarrow [2, 7] \\
4 & \rightarrow [5, 7] \\
5 & \rightarrow [6] \\
6 & \rightarrow [] \\
7 & \rightarrow [6] \\
\end{align*}

For the given graph, use DFS to figure out the topological sort. Show your steps and reasoning.

  \ifnum\me<2
\begin{solution}   PLEASE REFER TO THE HANDWRITTEN NOTES.   \end{solution}
	\fi

\end{subtasks}

\includegraphics[scale=0.75]{Problem Set 5/g2.png}

\begin{subtasks}
  
 \item \points{2} 
Simulate the working of Dijkstra’s algorithm for the above graph starting from vertex $1$.   
  \ifnum\me<2
\begin{solution}   PLEASE REFER TO THE HANDWRITTEN NOTES.   \end{solution}
	\fi

 \end{subtasks}

\includegraphics[scale=0.75]{Problem Set 5/g.png}

\begin{subtasks}
    
 \item \points{2} 
Illustrate a run of Kruskal’s algorithm on the above graph. (State at each step which edge is added to the
 tree).   
  \ifnum\me<2
\begin{solution}   PLEASE REFER TO THE HANDWRITTEN NOTES.   \end{solution}
	\fi

  \item \points{2} 
Illustrate a run of Prim’s algorithm on the above graph starting from vertex $1$. (State at each step which
 edge is added to the tree). 
  \ifnum\me<2
\begin{solution}   PLEASE REFER TO THE HANDWRITTEN NOTES.   \end{solution}
\fi

  \item \points{3} 
In a multi-threaded application, certain threads must be executed before others due to specific resource dependencies or operation sequences that need to be maintained. Consider a CPU scheduler tasked with determining the order of thread execution. Given a list of threads $T_1, T_2, \ldots, T_n$ and a set of dependencies where a dependency $T_i \rightarrow T_j$ means thread $T_i$ must be executed before thread $T_j$. Describe how you could apply an algorithm to determine a sequence for executing the threads that respects all the given dependencies, ensuring no thread is started before all the threads it depends on have been completed. 
  \ifnum\me<2
\begin{solution}   PLEASE REFER TO THE HANDWRITTEN NOTES.   \end{solution}
\fi

\end{subtasks}
 
\newproblem{A Sickly Affair}{\currentpoints}

You live in a dorm at node $s$ of a weighted directed graph $G = (V,E)$ with
non-negative weights and $n=|V|$ and $m=|E|$. One day, your friend who dorms at node $h$ falls sick and needs your help.  Naturally, you want to get from $s$ to $h$ as soon 
as possible, but you are supposed to stop by a pharmacy. You can get pills 
at any pharmacy, and the pharmacies form a subset of the vertices 
$P\subset V$. Thus, starting at $s$, you must go to some node $p\in P$ of 
your choice, and then head from $p$ to $h$ using the shortest total route possible.

\begin{subtasks}
	
	\item \points{4} Think of the problem as being subdivided into two parts, first of computing shortest distances to all pharmacies $p\in P$. And second of  computing the shortest path from every pharmacy $p\in P$ to $h$. Solve the problem using calls to the Dijkstra's algorithm. \hint{ Think about how we can manipulate the graph to solve the second subpart in one call.} 
	\ifnum\me<2
\begin{solution}  

Since we need to make sure we stop by the pharmacy, the best possible I am thinking of is:\\

1) Start Dijkstra's algorithm and run it through all the nodes and also maintain the parent node pointer for each of the nodes which will end up in the array with all keys and shortest path values.\\

2) Once we have that array filled with values, we would be exclusively interested in the values of $p$ nodes, as they are our pharmacies, and they will be the shortest ones by definition.\\

3) Now, that we are interested in all the shortest paths from pharmacies to the final destination node $h$, it would make sense for us to revert the direction of all the edges in the given graph and run Dijkstra's algorithm on node $h$ to figure out what are the shortest distances to $h$ node. Keep in mind, that this is basically doing step 1, but with respect to the $h$ node on a reverted graph, so we need to keep the information about the node's predecessor as well.\\

4) Upon completion of generating the array in step 3, we would be able to get arr[p] producing the shortest distance from $p\to h$. Additionally, you should be able to calculate the minimum sum of both paths and check the parents to retrace the path back.

\end{solution}
	\fi
		
	\item \points{5}
	Define a new graph
	$G'$ on at most $2n$ vertices and at most $2m+n$ edges (and ``appropriate''
	weights on these edges), so that the original problem can be solved
	using a {\em single} Dijkstra call on $G'$.
	
	\ifnum\me<2
\begin{solution} \\
1) Graph $G'$ would contain a duplicate of each vertex $v$ in the graph $G$ and their respective edges, to end up with $2n$ vertices and $2m$ edges in the graph $G'$. \\

2) After that, for each pharmacy $p$ add all edges of weight 0 from $p$ to $p'$. Run Djikstra’s algorithm starting from $s$. We must end up with shortest paths leading us to the $h'$ after the succesful run of Djikstra’s algorithm.\\

3) Trace back the $h'$ node and their respective parent pointers, which we maintained as per the previous solution. This will lead us to the pharmacy $p$ we visited. If we continue tracing back, we will eventually reach $s$ reconstructing the entire path for us and doing it in just one Djikstra call.
\end{solution}
	\fi
	
	\item \ecpoints{5} 
Assume now that, in addition to pills, you also need to get food, and the set of restaurants is
	$R\subset V$. You can visit them in any order and you want the find the best combination that leads to the shortest path. Show how to solve this problem by using a {\em single} Dijkstra	call on an 
	``appropriate'' graph $G'$, which uses as few copies of $G$ as possible. 

	
	\ifnum\me<2
\begin{solution}  Do the same thing, but now instead of duplicating it twice, we need to duplicate it 3 times, so that we can get the appropriate number of copies to operate on the next point of crossing, which is getting food.
\end{solution}
	\fi
	
\end{subtasks}

 \newproblem{Evince}{\currentpoints}
\begin{subtasks}


\item \points{4} Show that a graph has a unique minimum spanning tree if, for every cut of the 
graph, there is a unique light edge crossing the cut. Show that the converse is not 
true by giving a counterexample. An edge is a light edge crossing a cut if its weight is the minimum of any 
edge crossing the cut.

\ifnum\me<2
\begin{solution}\\
The entire idea is that there can’t be two MSTs, and thus it has to be unique. If there are two unique ones it suggests that the light edge does exist in one of the MSTs and does not exist in the other one, which is a contradiction. By definition of the MST, if that was the case there must be \textbf{some other edge} in the other tree that still would connect the two disconnected components, which is not what is described by this problem, hence there can only exist one unique MST.
\end{solution}
\fi

\item \points{5} Let $T$ be a minimum spanning tree of a graph $G$, and let $L$ be the sorted list of the edge weights of $T$. Argue that for any other minimum spanning tree $T'$ of $G$, the list $L$ is also the sorted list of edge weights of $T'$.

\ifnum\me<2
\begin{solution}\\
First of all, we can construct an arbitrary minimum spanning tree $R$ of an arbitrary graph $W$ using Kruskal's algorithm. The algorithm in the essence is working in a way that we add all the nodes to the MST as long as there is no cycle + we add the edges (and their respective nodes) systematically by the increasing order of weights. If $L$ is the sorted list of the edge weights of $T$ and $T'$ is some other minimum spanning tree of $G$, then to construct that $T'$ we would also use Kruskal's algorithm, which prescribes us to use the increasing order of weights to construct the edges and find out the nodes of the MST. It could be that $T$ and $T'$ have a number of similarly weighted edges, and that we preferred one over the other in different spanning trees, thus ended up in \textbf{different MSTs}. In principle, however, there are cycles generated in this scenario, and since weights must remain unchanged, we will always end up \textbf{not having the same} sorted list $L$ of weights for both $T$ and $T'$, since they both represent the same graph, and thus weights would have remain the same and no cycles can be formed.
\end{solution}
\fi



\item \points{5} Assume that all edge weights of a given undirected graph G = (V, E) are promised to be 1 except for a single edge \(e_0 = (u_0, v_0)\) whose weight is \(w_0\) (note, \(w_0\) might be either larger or smaller than \(1\)). Show how to compute MST of \(G\) in time $O(V+E)$.

\ifnum\me<2
\begin{solution}\\
1) First check to see if the weigtht of the given edge != 1, thus is less than or greater than 1. In case of the edge being greater, discard it. Otherwise, keep it.\\

2) Run DFS on the edges and vertices, which will construct a MST of G in time $O(V+E)$, since the time complexity of DFS is $O(V+E)$, where $V$ is the number of vertices and $E$ is the number of edges.\\
\end{solution}
\fi
\end{subtasks}

 \newproblem{Haphazard}{\currentpoints}
\begin{subtasks}
    \item \points{5}The New York electrical network consists of $n$ power plants and $n^2$ buildings. These entities are interconnected by bidirectional wires, allowing pairs of either type to be directly connected. For any two entities, there can only ever be one wire connecting them. A building receives power if it is directly connected to a power plant or indirectly through a chain of buildings that leads back to a power plant. It is important to note that each building can receive power from only one power plant to prevent ambiguity in power source accounting. To enhance resilience against power failures, New York plans to equip one power plant with an emergency generator. This generator will ensure backup power to all buildings linked to it should the primary power source fail. Given a list $W$ of all connections in the network, give an algorithm that runs in time $O(n^4)$ to identify the optimal power plant for the emergency generator installation. This selection aims to maximize the number of buildings receiving backup power in the event of a failure.


\ifnum\me<2
\begin{solution}\\

To solve this problem, we need to check all of the power plant nodes, checking all of the nodes that are attached to the power plant node. We are interested in getting the power plant that has the highest usage by the households, so that in case of an emergency we can accommodate the most number of users with our scarce resources. We can achieve that by keeping a counter of the nodes that each power plant node would service if we attached the generator to it. If one of the nodes attached to the power plant node is a power plant node, we don’t count it. Furthermore, if a node that is attached to the power plant node we’re inspecting is attached to another power plant node, we don’t count it. Whichever power plant has the highest counter value is the one we should install the generator into, as it is the one that would service the most nodes were it to be installed.\\

When we are running Prim's algorithm for every power plant node, run additional Prim's algorithm to figure out which buildings are already connected to other plants, if they are the counter is not incremented, but if they are not the counter for that power plant would be incremented. Finally, iterate over all the combos and return the power plant which would have the highest counter value. This complex procedure would take $O(n^4)$ time.


\end{solution}
\fi

\item \points{8} A game has $n$ rooms and $m$ tunnels between them. Each room has a certain number of coins. What is the maximum number of coins you can collect while moving through the tunnels when you can freely choose your starting and ending room? Each tunnel is a one-way tunnel.
\ifnum\me<2
\begin{solution}

1) Perform DFS on the original graph to find the topological ordering of the nodes.\\

2) Then perform DFS traversal on the reversed graph in order to label nodes with their respective SCCs.\\

3) After labeling nodes with their respective SCCs, calculate the sum of coins within each SCC.\\

4) Build a new graph where each new node represents an SCC, and there is a directed edge from an arbitrary SCC $u$ to an arbitrary SCC $v$ if there's an edge from any node in $u$ to any node in $v$ in the original graph.\\

5) Perform dynamic programming recursion to find out what is the maximum number of coins reachable from each SCC, where for each SCC, we consider adding the sum of coins in that SCC to the maximum number of coins reachable from any SCC it can reach.\\

6) Return the maximum value found in the traversal of the SCCs in the newly constructed graph.\\ 

\end{solution}
\fi

\end{subtasks}

\end{document}


